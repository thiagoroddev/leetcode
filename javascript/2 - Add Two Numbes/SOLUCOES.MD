# Add Two Numbers - LeetCode #2

## üìã Descri√ß√£o do Problema

Voc√™ recebe duas **listas encadeadas n√£o vazias** representando dois n√∫meros inteiros n√£o negativos. Os d√≠gitos s√£o armazenados em **ordem inversa** e cada n√≥ cont√©m um √∫nico d√≠gito. Some os dois n√∫meros e retorne a soma como uma lista encadeada.

Voc√™ pode assumir que os dois n√∫meros n√£o cont√™m zeros √† esquerda, exceto o n√∫mero 0 em si.

### Exemplo 1:
```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explica√ß√£o: 342 + 465 = 807
```

### Exemplo 2:
```
Input: l1 = [0], l2 = [0]
Output: [0]
```

### Exemplo 3:
```
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
Explica√ß√£o: 9999999 + 9999 = 10009998
```

### Restri√ß√µes:
- O n√∫mero de n√≥s em cada lista est√° no intervalo `[1, 100]`
- `0 <= Node.val <= 9`
- √â garantido que a lista representa um n√∫mero que n√£o possui zeros √† esquerda

---

## üéØ Conceitos Importantes para Iniciantes

### O que √© uma Lista Encadeada (Linked List)?

Uma lista encadeada √© uma estrutura de dados onde cada elemento (n√≥) cont√©m:
- Um **valor** (data)
- Uma **refer√™ncia** para o pr√≥ximo n√≥ (next)

```javascript
// Defini√ß√£o da estrutura de um n√≥
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val)
    this.next = (next === undefined ? null : next)
}
```

**Visualiza√ß√£o:**
```
[2] -> [4] -> [3] -> null
 ‚Üë      ‚Üë      ‚Üë
n√≥1    n√≥2    n√≥3
```

### Por que os n√∫meros est√£o em ordem inversa?

Isso facilita a soma! Come√ßamos somando as unidades, depois as dezenas, depois as centenas, etc.

**Exemplo:**
- N√∫mero: 342
- Lista: [2, 4, 3]
- Representa: 2 (unidades) + 4√ó10 (dezenas) + 3√ó100 (centenas)

---

## üí° Solu√ß√µes

## Solu√ß√£o 1: Iterativa (Recomendada para Iniciantes)

### Abordagem
Percorremos ambas as listas simultaneamente, somando os valores correspondentes e gerenciando o "vai um" (carry).

### C√≥digo Comentado
```javascript
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    // Criamos um n√≥ fict√≠cio (dummy) para facilitar a constru√ß√£o da lista resultado
    let dummyHead = new ListNode(0);
    
    // Ponteiro que vai construindo a lista resultado
    let current = dummyHead;
    
    // Vari√°vel para armazenar o "vai um" da soma
    let carry = 0;
    
    // Continuamos enquanto houver n√≥s em l1, l2 ou carry para processar
    while (l1 !== null || l2 !== null || carry !== 0) {
        // Pega o valor do n√≥ atual de l1 (ou 0 se l1 j√° terminou)
        let val1 = l1 !== null ? l1.val : 0;
        
        // Pega o valor do n√≥ atual de l2 (ou 0 se l2 j√° terminou)
        let val2 = l2 !== null ? l2.val : 0;
        
        // Soma os dois valores mais o carry anterior
        let sum = val1 + val2 + carry;
        
        // Calcula o novo carry (vai um)
        // Se sum = 15, carry = 1
        // Se sum = 7, carry = 0
        carry = Math.floor(sum / 10);
        
        // O d√≠gito a ser armazenado √© o resto da divis√£o por 10
        // Se sum = 15, digit = 5
        // Se sum = 7, digit = 7
        let digit = sum % 10;
        
        // Cria um novo n√≥ com o d√≠gito calculado
        current.next = new ListNode(digit);
        
        // Move o ponteiro para o pr√≥ximo n√≥
        current = current.next;
        
        // Avan√ßa para o pr√≥ximo n√≥ em l1 (se existir)
        if (l1 !== null) l1 = l1.next;
        
        // Avan√ßa para o pr√≥ximo n√≥ em l2 (se existir)
        if (l2 !== null) l2 = l2.next;
    }
    
    // Retorna a lista resultado (pulando o n√≥ dummy)
    return dummyHead.next;
};
```

### Complexidade
- **Tempo:** O(max(m, n)) - onde m e n s√£o os tamanhos de l1 e l2
- **Espa√ßo:** O(max(m, n)) - para armazenar a lista resultado

### Exemplo Passo a Passo

Vamos somar `342 + 465`:
- l1 = [2, 4, 3]
- l2 = [5, 6, 4]

**Itera√ß√£o 1:**
```
val1 = 2, val2 = 5, carry = 0
sum = 2 + 5 + 0 = 7
carry = 7 / 10 = 0
digit = 7 % 10 = 7
Resultado at√© agora: [7]
```

**Itera√ß√£o 2:**
```
val1 = 4, val2 = 6, carry = 0
sum = 4 + 6 + 0 = 10
carry = 10 / 10 = 1
digit = 10 % 10 = 0
Resultado at√© agora: [7, 0]
```

**Itera√ß√£o 3:**
```
val1 = 3, val2 = 4, carry = 1
sum = 3 + 4 + 1 = 8
carry = 8 / 10 = 0
digit = 8 % 10 = 8
Resultado at√© agora: [7, 0, 8]
```

**Resultado Final:** [7, 0, 8] que representa 807 ‚úÖ

---

## Solu√ß√£o 2: Recursiva

### Abordagem
Usamos recurs√£o para somar cada par de n√≥s. Como n√£o podemos adicionar par√¢metros extras, criamos uma fun√ß√£o auxiliar interna para gerenciar o carry.

### C√≥digo Comentado
```javascript
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    // Fun√ß√£o auxiliar recursiva que recebe o carry
    const addWithCarry = (l1, l2, carry) => {
        // Caso base: se ambas as listas terminaram e n√£o h√° carry
        if (l1 === null && l2 === null && carry === 0) {
            return null;
        }
        
        // Obt√©m os valores (ou 0 se a lista j√° terminou)
        let val1 = l1 !== null ? l1.val : 0;
        let val2 = l2 !== null ? l2.val : 0;
        
        // Calcula a soma
        let sum = val1 + val2 + carry;
        
        // Cria o novo n√≥ com o d√≠gito
        let newNode = new ListNode(sum % 10);
        
        // Obt√©m os pr√≥ximos n√≥s (ou null se n√£o existirem)
        let next1 = l1 !== null ? l1.next : null;
        let next2 = l2 !== null ? l2.next : null;
        
        // Chamada recursiva para os pr√≥ximos n√≥s
        newNode.next = addWithCarry(next1, next2, Math.floor(sum / 10));
        
        return newNode;
    };
    
    // Inicia a recurs√£o com carry = 0
    return addWithCarry(l1, l2, 0);
};
```

### Complexidade
- **Tempo:** O(max(m, n))
- **Espa√ßo:** O(max(m, n)) - devido √† pilha de recurs√£o

---

## Solu√ß√£o 3: Vers√£o Mais Limpa (C√≥digo Conciso)

### C√≥digo Comentado
```javascript
var addTwoNumbers = function(l1, l2) {
    let dummy = new ListNode(0); // Cria um n√≥ fict√≠cio (dummy) para facilitar a constru√ß√£o da lista resultado
    let curr = dummy; // Inicializa o ponteiro atual para o n√≥ de resultado
    let carry = 0; // Vari√°vel para armazenar o "vai um" (carry)
    
    while (l1 || l2 || carry) {
        // Usa operador OR para pegar valor ou 0
        const sum = (l1?.val || 0) + (l2?.val || 0) + carry;
        
        carry = Math.floor(sum / 10); // Calcula o novo carry
        curr.next = new ListNode(sum % 10); // Cria o novo n√≥ com o d√≠gito
        curr = curr.next; // Avan√ßa para o pr√≥ximo n√≥ de resultado
        
        // Usa operador de encadeamento opcional
        l1 = l1?.next;
        l2 = l2?.next;
    }
    
    return dummy.next;
};
```

### O que √© `?.` (Optional Chaining)?
O operador `?.` permite acessar propriedades de um objeto que pode ser `null` ou `undefined` sem causar erro.

```javascript
// Sem optional chaining:
let val = l1 !== null ? l1.val : 0;

// Com optional chaining:
let val = l1?.val || 0;
```

---

## Solu√ß√£o 4: Com BigInt (Para N√∫meros Muito Grandes)

### ‚ö†Ô∏è Aviso
Esta solu√ß√£o **N√ÉO √© aceita** pelo LeetCode para este problema, pois converte a lista em n√∫mero. Mas √© √∫til para entender o problema!

### C√≥digo Comentado
```javascript
var addTwoNumbers = function(l1, l2) {
    // Fun√ß√£o auxiliar para converter lista em n√∫mero
    const listToNumber = (list) => {
        let num = BigInt(0);
        let multiplier = BigInt(1);
        
        while (list !== null) {
            num += BigInt(list.val) * multiplier;
            multiplier *= BigInt(10);
            list = list.next;
        }
        
        return num;
    };
    
    // Fun√ß√£o auxiliar para converter n√∫mero em lista
    const numberToList = (num) => {
        if (num === BigInt(0)) return new ListNode(0);
        
        let dummy = new ListNode(0);
        let current = dummy;
        
        while (num > BigInt(0)) {
            let digit = num % BigInt(10);
            current.next = new ListNode(Number(digit));
            current = current.next;
            num = num / BigInt(10);
        }
        
        return dummy.next;
    };
    
    // Converte listas em n√∫meros, soma e converte de volta
    let num1 = listToNumber(l1);
    let num2 = listToNumber(l2);
    let sum = num1 + num2;
    
    return numberToList(sum);
};
```

**Por que usar BigInt?**
- JavaScript tem limite para n√∫meros: at√© 2^53 - 1
- BigInt permite trabalhar com n√∫meros arbitrariamente grandes
- √ötil quando os n√∫meros t√™m muitos d√≠gitos

---

## üîß Fun√ß√µes Auxiliares para Testar

### Criar Lista Encadeada a partir de Array
```javascript
function createLinkedList(arr) {
    if (arr.length === 0) return null;
    
    let head = new ListNode(arr[0]);
    let current = head;
    
    for (let i = 1; i < arr.length; i++) {
        current.next = new ListNode(arr[i]);
        current = current.next;
    }
    
    return head;
}
```

### Converter Lista Encadeada em Array
```javascript
function linkedListToArray(head) {
    let arr = [];
    let current = head;
    
    while (current !== null) {
        arr.push(current.val);
        current = current.next;
    }
    
    return arr;
}
```

### Imprimir Lista Encadeada
```javascript
function printLinkedList(head) {
    let arr = linkedListToArray(head);
    console.log(arr.join(' -> '));
}
```

### Exemplo de Uso
```javascript
// Criar listas de teste
let l1 = createLinkedList([2, 4, 3]);
let l2 = createLinkedList([5, 6, 4]);

// Somar
let result = addTwoNumbers(l1, l2);

// Imprimir resultado
printLinkedList(result); // 7 -> 0 -> 8
console.log(linkedListToArray(result)); // [7, 0, 8]
```

---

## üéì Conceitos de JavaScript Explicados

### 1. Math.floor() vs parseInt()
```javascript
// Math.floor() - arredonda para baixo
Math.floor(15 / 10); // 1
Math.floor(7 / 10);  // 0

// parseInt() - converte string para inteiro
parseInt("15"); // 15
```

### 2. Operador M√≥dulo (%)
```javascript
// Retorna o resto da divis√£o
15 % 10; // 5
7 % 10;  // 7
20 % 10; // 0
```

### 3. Operador Tern√°rio (? :)
```javascript
// Sintaxe: condi√ß√£o ? valorSeVerdadeiro : valorSeFalso
let val = l1 !== null ? l1.val : 0;

// Equivalente a:
let val;
if (l1 !== null) {
    val = l1.val;
} else {
    val = 0;
}
```

### 4. Optional Chaining (?.)
```javascript
// Evita erro quando objeto √© null/undefined
let val = l1?.val; // undefined se l1 √© null

// Sem optional chaining:
let val = l1 && l1.val; // mais verboso
```

### 5. Nullish Coalescing (||)
```javascript
// Retorna valor √† direita se esquerda for falsy
let val = l1?.val || 0;

// Se l1.val √© 0, null, undefined, false -> retorna 0
```

---

## üêõ Erros Comuns para Evitar

### 1. Esquecer de Lidar com Carry Final
```javascript
// ‚ùå ERRADO
while (l1 || l2) { // Esqueceu do carry!
    // ...
}

// ‚úÖ CORRETO
while (l1 || l2 || carry) {
    // ...
}
```

### 2. N√£o Verificar null antes de Acessar .val
```javascript
// ‚ùå ERRADO
let val1 = l1.val; // Erro se l1 √© null!

// ‚úÖ CORRETO
let val1 = l1 !== null ? l1.val : 0;
// ou
let val1 = l1?.val || 0;
```

### 3. N√£o Retornar dummy.next
```javascript
// ‚ùå ERRADO
return dummy; // Retorna o n√≥ dummy!

// ‚úÖ CORRETO
return dummy.next; // Retorna o primeiro n√≥ real
```

### 4. Esquecer de Avan√ßar os Ponteiros
```javascript
// ‚ùå ERRADO
while (l1 || l2) {
    // ... processar
    // Esqueceu: l1 = l1.next; l2 = l2.next;
} // Loop infinito!
```

---

## üìä Compara√ß√£o de Solu√ß√µes

| Solu√ß√£o | Tempo | Espa√ßo | Dificuldade | Recomenda√ß√£o |
|---------|-------|--------|-------------|--------------|
| Iterativa | O(max(m,n)) | O(max(m,n)) | F√°cil | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Melhor para iniciantes |
| Recursiva | O(max(m,n)) | O(max(m,n)) | M√©dia | ‚≠ê‚≠ê‚≠ê Boa para praticar recurs√£o |
| Concisa | O(max(m,n)) | O(max(m,n)) | F√°cil | ‚≠ê‚≠ê‚≠ê‚≠ê Quando j√° dominar o b√°sico |
| BigInt | O(m+n) | O(m+n) | F√°cil | ‚ùå N√£o aceita no LeetCode |

---

## üéØ Dicas de Estudo

1. **Comece com papel e caneta:** Desenhe as listas e simule a soma manualmente
2. **Use console.log():** Imprima os valores em cada itera√ß√£o para entender o fluxo
3. **Teste casos extremos:**
   - Listas de tamanhos diferentes
   - Carry no √∫ltimo n√≥: [9,9,9] + [1]
   - N√∫meros com zero: [0] + [0]
4. **Pratique criar e percorrer listas encadeadas** antes de tentar este problema
5. **Entenda o conceito de dummy node** - facilita muito!

---

## üîó Recursos Adicionais

- [Visualiza√ß√£o de Listas Encadeadas](https://visualgo.net/en/list)
- [MDN - Operadores JavaScript](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Expressions_and_Operators)
- [LeetCode Discuss - Add Two Numbers](https://leetcode.com/problems/add-two-numbers/discuss/)

---

## üìù Exerc√≠cios Relacionados

Ap√≥s dominar este problema, tente:
- **LeetCode #445** - Add Two Numbers II (n√∫meros em ordem normal)
- **LeetCode #21** - Merge Two Sorted Lists
- **LeetCode #2** - Reverse Linked List

---

**Autor:** Criado para estudo e consulta futura  
**Data:** Dezembro 2025  
**Problema:** [LeetCode #2 - Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)

---

## ‚≠ê Se este README te ajudou, deixe uma estrela no reposit√≥rio!